const { z } = require('zod');
const pdfModel = require('../../models/pdfModel');
const geminiService = require('../geminiService');
const chatModel = require('../../models/chatModel');
const { ResourceTemplate } = require('@modelcontextprotocol/sdk/server/mcp.js');
const axios = require('axios');
const { OpenAI } = require('openai');

// ƒêƒÉng k√Ω c√°c resources
const registerResources = (server) => {
  // PDF Resource
  server.resource(
    "pdf",
    new ResourceTemplate("pdf://{pdfId}", { list: undefined }),
    async (uri, { pdfId }) => {
      try {
        console.log("üîç MCP: ƒêang truy c·∫≠p PDF v·ªõi ID:", pdfId);
        const pdf = await pdfModel.getPDFById(pdfId);
        if (!pdf) {
          throw new Error(`Kh√¥ng t√¨m th·∫•y PDF v·ªõi ID: ${pdfId}`);
        }
        
        return {
          contents: [{
            uri: uri.href,
            text: pdf.full_text || "Kh√¥ng c√≥ n·ªôi dung",
            metadata: {
              title: pdf.pdf_name,
              created_at: pdf.uploaded_at,
              author: pdf.uploaded_by_name,
              file_type: pdf.file_type
            }
          }]
        };
      } catch (error) {
        console.error("‚ùå MCP: L·ªói khi ƒë·ªçc PDF:", error);
        throw error;
      }
    }
  );

  // Danh s√°ch PDF Resource
  server.resource(
    "pdfs",
    "pdfs://list",
    async () => {
      try {
        console.log("üîç MCP: ƒêang l·∫•y danh s√°ch PDF");
        const pdfs = await pdfModel.getAllPDFs();
        
        const formattedPdfs = pdfs.map(pdf => ({
          id: pdf.id,
          title: pdf.pdf_name,
          uploaded_at: pdf.uploaded_at,
          author: pdf.uploaded_by_name
        }));
        
        return {
          contents: [{
            uri: "pdfs://list",
            text: JSON.stringify(formattedPdfs, null, 2)
          }]
        };
      } catch (error) {
        console.error("‚ùå MCP: L·ªói khi l·∫•y danh s√°ch PDF:", error);
        throw error;
      }
    }
  );

  // PDF Chunks Resource
  server.resource(
    "pdf-chunks",
    new ResourceTemplate("pdf-chunks://{pdfId}", { list: undefined }),
    async (uri, { pdfId }) => {
      try {
        console.log("üîç MCP: ƒêang l·∫•y chunks c·ªßa PDF v·ªõi ID:", pdfId);
        const chunks = await pdfModel.getPDFChunks(pdfId);
        
        return {
          contents: chunks.map((chunk, index) => ({
            uri: `${uri.href}/chunk/${index}`,
            text: chunk.chunk_text,
            metadata: {
              index: index,
              chunk_id: chunk.id
            }
          }))
        };
      } catch (error) {
        console.error("‚ùå MCP: L·ªói khi l·∫•y PDF chunks:", error);
        throw error;
      }
    }
  );
};

// ƒêƒÉng k√Ω c√°c tools
const registerTools = (server) => {
  // Tool t√¨m ki·∫øm PDF
  server.tool(
    "search-pdf",
    {
      query: z.string(),
      pdfId: z.string().optional()
    },
    async ({ query, pdfId }) => {
      try {
        console.log("üîç MCP: ƒêang t√¨m ki·∫øm trong PDF:", { query, pdfId });
        
        let answer;
        if (pdfId) {
          // T√¨m ki·∫øm trong m·ªôt PDF c·ª• th·ªÉ
          const pdf = await pdfModel.getPDFById(pdfId);
          if (!pdf) {
            return {
              content: [{ type: "text", text: "Kh√¥ng t√¨m th·∫•y PDF" }],
              isError: true
            };
          }
          
          // L·∫•y chunks ƒë√£ ƒë∆∞·ª£c t·∫°o
          const chunks = await pdfModel.getPDFChunks(pdfId);
          
          // Chu·∫©n b·ªã d·ªØ li·ªáu cho smartSearch
          const searchData = {
            fileName: pdf.pdf_name,
            title: pdf.pdf_name,
            author: pdf.uploaded_by_name,
            created_at: pdf.uploaded_at,
            fullText: pdf.full_text,
            chunks: chunks.map(chunk => ({
              text: chunk.chunk_text,
              embedding: chunk.embedding
            })),
            queryEmbedding: await geminiService.createEmbedding(query)
          };
          
          // S·ª≠ d·ª•ng smartSearch ƒë·ªÉ t√¨m ki·∫øm
          answer = await geminiService.smartSearch(query, searchData);
        } else {
          // T√¨m ki·∫øm trong t·∫•t c·∫£ PDF
          const similarityThreshold = 0.2;
          const maxResults = 10;
          
          const searchResults = await pdfModel.getVectorSearchResultWithRoles(
            await geminiService.createEmbedding(query),
            null,
            ['admin'],
            similarityThreshold,
            maxResults
          );
          
          if (!searchResults || searchResults.length === 0) {
            return {
              content: [{ type: "text", text: "Kh√¥ng t√¨m th·∫•y th√¥ng tin li√™n quan ƒë·∫øn c√¢u h·ªèi c·ªßa b·∫°n." }],
              isError: true
            };
          }
          
          console.log(`‚úÖ T√¨m th·∫•y ${searchResults.length} t√†i li·ªáu ph√π h·ª£p v·ªõi ƒë·ªô t∆∞∆°ng ƒë·ªìng > ${similarityThreshold}`);
          
          // ƒê·ªãnh d·∫°ng k·∫øt qu·∫£
          answer = searchResults.map(result => ({
            pdf_id: result.pdf_id,
            pdf_name: result.pdf_name,
            chunks: result.chunks.map(chunk => ({
              content: chunk.content,
              similarity: chunk.similarity,
              section_title: chunk.section_title
            }))
          }));
        }
        
        return {
          content: [{ type: "text", text: JSON.stringify(answer, null, 2) }]
        };
      } catch (error) {
        console.error("‚ùå MCP: L·ªói khi t√¨m ki·∫øm:", error);
        return {
          content: [{ type: "text", text: `L·ªói: ${error.message}` }],
          isError: true
        };
      }
    }
  );

  // Tool t·∫°o embedding
  server.tool(
    "create-embedding",
    {
      text: z.string()
    },
    async ({ text }) => {
      try {
        console.log("üî§ MCP: ƒêang t·∫°o embedding...");
        const embedding = await geminiService.createEmbedding(text);
        
        return {
          content: [{ 
            type: "text", 
            text: `Embedding ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng (${embedding.length} chi·ªÅu)`
          }],
          data: { embedding }
        };
      } catch (error) {
        console.error("‚ùå MCP: L·ªói khi t·∫°o embedding:", error);
        return {
          content: [{ type: "text", text: `L·ªói: ${error.message}` }],
          isError: true
        };
      }
    }
  );

  // Tool l∆∞u l·ªãch s·ª≠ chat
  server.tool(
    "save-chat-history",
    {
      userId: z.string(),
      query: z.string(),
      response: z.string(),
      source: z.string().optional()
    },
    async ({ userId, query, response, source }) => {
      try {
        console.log("üíæ MCP: ƒêang l∆∞u l·ªãch s·ª≠ chat...");
        const chatId = await chatModel.saveChatHistory(
          userId, 
          query, 
          response, 
          source || "MCP"
        );
        
        return {
          content: [{ 
            type: "text", 
            text: `L·ªãch s·ª≠ chat ƒë√£ ƒë∆∞·ª£c l∆∞u v·ªõi ID: ${chatId}`
          }],
          data: { chatId }
        };
      } catch (error) {
        console.error("‚ùå MCP: L·ªói khi l∆∞u l·ªãch s·ª≠ chat:", error);
        return {
          content: [{ type: "text", text: `L·ªói: ${error.message}` }],
          isError: true
        };
      }
    }
  );
};

// ƒêƒÉng k√Ω c√°c prompts
const registerPrompts = (server) => {
  // Prompt h·ªèi v·ªÅ PDF
  server.prompt(
    "question-pdf",
    { 
      question: z.string(),
      pdfId: z.string().optional() 
    },
    ({ question, pdfId }) => {
      if (pdfId) {
        return {
          messages: [{
            role: "user",
            content: {
              type: "text",
              text: `D·ª±a tr√™n t√†i li·ªáu PDF c√≥ ID ${pdfId}, h√£y tr·∫£ l·ªùi c√¢u h·ªèi sau b·∫±ng ti·∫øng Vi·ªát: ${question}`
            }
          }]
        };
      } else {
        return {
          messages: [{
            role: "user",
            content: {
              type: "text",
              text: `H√£y tr·∫£ l·ªùi c√¢u h·ªèi sau b·∫±ng ti·∫øng Vi·ªát, d·ª±a tr√™n ki·∫øn th·ª©c c·ªßa b·∫°n: ${question}`
            }
          }]
        };
      }
    }
  );

  // Prompt ph√¢n t√≠ch PDF
  server.prompt(
    "analyze-pdf",
    { 
      pdfId: z.string(),
      analysisType: z.enum(['summary', 'keywords', 'sentiment', 'full'])
    },
    ({ pdfId, analysisType }) => {
      let promptText = `H√£y ph√¢n t√≠ch t√†i li·ªáu PDF c√≥ ID ${pdfId}`;
      
      switch (analysisType) {
        case 'summary':
          promptText += " v√† cung c·∫•p m·ªôt b·∫£n t√≥m t·∫Øt ng·∫Øn g·ªçn c·ªßa n·ªôi dung ch√≠nh.";
          break;
        case 'keywords':
          promptText += " v√† tr√≠ch xu·∫•t c√°c t·ª´ kh√≥a quan tr·ªçng nh·∫•t.";
          break;
        case 'sentiment':
          promptText += " v√† ph√¢n t√≠ch gi·ªçng ƒëi·ªáu, quan ƒëi·ªÉm c·ªßa t√†i li·ªáu.";
          break;
        case 'full':
          promptText += " v√† cung c·∫•p ph√¢n t√≠ch ƒë·∫ßy ƒë·ªß bao g·ªìm: t√≥m t·∫Øt, t·ª´ kh√≥a, quan ƒëi·ªÉm, √Ω ch√≠nh v√† ƒë·ªëi t∆∞·ª£ng m·ª•c ti√™u.";
          break;
      }
      
      return {
        messages: [{
          role: "user",
          content: {
            type: "text",
            text: promptText
          }
        }]
      };
    }
  );

  server.prompt(
    "translate-pdf",
    { 
      pdfId: z.string(),
      targetLanguage: z.string().default('Vietnamese')
    },
    ({ pdfId, targetLanguage }) => {
      return {
        messages: [{
          role: "user",
          content: {
            type: "text",
            text: `H√£y d·ªãch n·ªôi dung c·ªßa t√†i li·ªáu PDF c√≥ ID ${pdfId} sang ${targetLanguage}, gi·ªØ nguy√™n ƒë·ªãnh d·∫°ng v√† c·∫•u tr√∫c c√†ng nhi·ªÅu c√†ng t·ªët.`
          }
        }]
      };
    }
  );
};

async function searchPDF(query, pdfId = null, userId = null, userRoles = ['admin'], conversationHistory = []) {
    try {
        console.log(`üîç T√¨m ki·∫øm v·ªõi query: "${query}" ${pdfId ? `trong PDF ID: ${pdfId}` : ''}`);
        
        // 1. T·∫°o embedding cho c√¢u query
        const queryEmbedding = await createEmbedding(query);
        if (!queryEmbedding) {
            console.error("‚ùå Kh√¥ng th·ªÉ t·∫°o embedding cho query");
            return "Kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu t√¨m ki·∫øm. Vui l√≤ng th·ª≠ l·∫°i.";
        }
        
        let searchResults;
        
        // 2. T√¨m trong PDF c·ª• th·ªÉ ho·∫∑c t·∫•t c·∫£ PDF
        if (pdfId) {
            // Ki·ªÉm tra PDF t·ªìn t·∫°i
            const pdf = await pdfModel.getPDFById(pdfId);
            if (!pdf) {
                return `Kh√¥ng t√¨m th·∫•y PDF v·ªõi ID: ${pdfId}`;
            }
            
            // T√¨m ki·∫øm trong PDF c·ª• th·ªÉ
            const similarChunks = await pdfModel.searchSimilarChunks(
                queryEmbedding,
                null,
                10,
                [pdfId]
            );
            
            if (!similarChunks || similarChunks.length === 0) {
                return `Kh√¥ng t√¨m th·∫•y th√¥ng tin li√™n quan trong PDF "${pdf.pdf_name}"`;
            }
            
            // ƒê·ªãnh d·∫°ng k·∫øt qu·∫£
            searchResults = [{
                pdf_id: pdfId,
                pdf_name: pdf.pdf_name,
                chunks: similarChunks.map(chunk => ({
                    content: chunk.content,
                    similarity: chunk.similarity,
                    section_title: chunk.section_title
                }))
            }];
        } else {
            // T√¨m ki·∫øm trong t·∫•t c·∫£ PDF ph√π h·ª£p v·ªõi quy·ªÅn
            const similarityThreshold = 0.2;
            
            searchResults = await pdfModel.getVectorSearchResultWithRoles(
                queryEmbedding,
                userId || 1,
                userRoles
            );
            
            if (!searchResults || searchResults.length === 0) {
                return "Kh√¥ng t√¨m th·∫•y th√¥ng tin li√™n quan ƒë·∫øn c√¢u h·ªèi c·ªßa b·∫°n.";
            }
            
            console.log(`‚úÖ T√¨m th·∫•y ${searchResults.length} t√†i li·ªáu ph√π h·ª£p v·ªõi ƒë·ªô t∆∞∆°ng ƒë·ªìng > ${similarityThreshold}`);
        }
        
        // Th√™m th√¥ng tin chi ti·∫øt v·ªÅ k·∫øt qu·∫£ t√¨m ki·∫øm
        if (searchResults && searchResults.length > 0) {
            console.log(`üìä Chi ti·∫øt k·∫øt qu·∫£ t√¨m ki·∫øm:`);
            searchResults.forEach((result, index) => {
                const avgSimilarity = result.chunks.reduce((sum, chunk) => sum + chunk.similarity, 0) / result.chunks.length;
                console.log(`   ${index+1}. ${result.pdf_name}: ${result.chunks.length} chunks, ƒë·ªô t∆∞∆°ng ƒë·ªìng TB: ${avgSimilarity.toFixed(4)}`);
            });
        }
        
        // 3. T·∫°o context t·ª´ k·∫øt qu·∫£ t√¨m ki·∫øm
        let context = "";
        let sourceInfo = "### NGU·ªíN T√ÄI LI·ªÜU:\n";
        let sourceCount = 1;

        searchResults.forEach(result => {
            sourceInfo += `${sourceCount}. ${result.pdf_name}\n`;
            context += `### T·∫§T C·∫¢ T√ÄI LI·ªÜU LI√äN QUAN ${sourceCount}: ${result.pdf_name}\n\n`;
            
            // S·∫Øp x·∫øp c√°c chunk theo ƒë·ªô t∆∞∆°ng ƒë·ªìng (cao ƒë·∫øn th·∫•p)
            const sortedChunks = result.chunks.sort((a, b) => b.similarity - a.similarity);
            
            sortedChunks.forEach(chunk => {
                if (chunk.section_title) {
                    context += `## ${chunk.section_title}\n`;
                }
                context += `${chunk.content}\n\n`;
            });
            
            context += "---\n\n";
            sourceCount++;
        });

        // Th√™m metadata v·ªÅ ngu·ªìn v√†o ƒë·∫ßu context
        context = sourceInfo + "\n\n" + context;
        
        // Th√™m l·ªãch s·ª≠ h·ªôi tho·∫°i v√†o prompt n·∫øu c√≥
        let conversationContext = "";
        if (conversationHistory && conversationHistory.length > 0) {
            conversationContext = "### L·ªäCH S·ª¨ H·ªòI THO·∫†I:\n";
            // L·∫•y t·ªëi ƒëa 3 l∆∞·ª£t g·∫ßn nh·∫•t
            const recentHistory = conversationHistory.slice(-6);
            for (let i = 0; i < recentHistory.length; i += 2) {
                if (recentHistory[i]) {
                    conversationContext += `Ng∆∞·ªùi d√πng: ${recentHistory[i].content}\n`;
                }
                if (recentHistory[i+1]) {
                    conversationContext += `Tr·ª£ l√Ω: ${recentHistory[i+1].content.substring(0, 200)}...\n\n`;
                }
            }
            conversationContext += "---\n\n";
        }

        // Th√™m v√†o ph·∫ßn ƒë·∫ßu c·ªßa context
        context = conversationContext + context;
        
        // 4. T·∫°o prompt cho LLM
        const systemPrompt = `B·∫°n l√† tr·ª£ l√Ω AI chuy√™n nghi·ªáp v·ªõi kh·∫£ nƒÉng ph√¢n t√≠ch t√†i li·ªáu chuy√™n s√¢u. B·∫°n lu√¥n cung c·∫•p c√¢u tr·∫£ l·ªùi TO√ÄN DI·ªÜN, D√ÄI v√† ƒê·∫¶Y ƒê·ª¶ CHI TI·∫æT. H√£y s·ª≠ d·ª•ng t·∫•t c·∫£ th√¥ng tin li√™n quan t·ª´ t√†i li·ªáu ƒë·ªÉ tr·∫£ l·ªùi. ƒê·ª´ng b·ªè s√≥t b·∫•t k·ª≥ n·ªôi dung quan tr·ªçng n√†o. Khi tr√≠ch d·∫´n, ch·ªâ ƒë·ªÅ c·∫≠p ƒë·∫øn t√™n ƒë·∫ßy ƒë·ªß c·ªßa t√†i li·ªáu n·∫øu bi·∫øt. KH√îNG s·ª≠ d·ª•ng c√°ch g·ªçi 'T√†i li·ªáu 1', 'T√†i li·ªáu 2'. N·∫øu kh√¥ng bi·∫øt t√™n t√†i li·ªáu, h√£y b·ªè qua vi·ªác ƒë·ªÅ c·∫≠p t√™n t√†i li·ªáu. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát.`;

        const prompt = `
        ${systemPrompt}

        ### TH√îNG TIN C√ì S·∫¥N:
        ${context}

        ### C√ÇU H·ªéI C·ª¶A NG∆Ø·ªúI D√ôNG:
        ${query}

        ### H∆Ø·ªöNG D·∫™N CHI TI·∫æT:
        1. Tr·∫£ l·ªùi PH·∫¢I d·ª±a ho√†n to√†n v√†o th√¥ng tin t·ª´ c√°c t√†i li·ªáu ƒë∆∞·ª£c cung c·∫•p. KH√îNG ƒë∆∞·ª£c t·ª± t·∫°o th√¥ng tin.
        2. N·∫øu t√†i li·ªáu ch·ª©a th√¥ng tin m√¢u thu·∫´n, h√£y ƒë·ªÅ c·∫≠p ƒê·∫¶Y ƒê·ª¶ c√°c quan ƒëi·ªÉm kh√°c nhau.
        3. Tr√¨nh b√†y th√¥ng tin m·ªôt c√°ch C√ì C·∫§U TR√öC v√† D·ªÑ HI·ªÇU:
            - B·∫Øt ƒë·∫ßu b·∫±ng c√¢u tr·∫£ l·ªùi t·ªïng quan
            - Ti·∫øp theo l√† c√°c lu·∫≠n ƒëi·ªÉm chi ti·∫øt k√®m v√≠ d·ª• t·ª´ t√†i li·ªáu
            - K·∫øt th√∫c b·∫±ng t√≥m t·∫Øt ng·∫Øn g·ªçn

        4. S·ª¨ D·ª§NG ƒê·ªäNH D·∫†NG ƒë·ªÉ l√†m n·ªïi b·∫≠t c√°c ƒëi·ªÉm quan tr·ªçng (in ƒë·∫≠m, in nghi√™ng, danh s√°ch).

        ### Y√äU C·∫¶U QUAN TR·ªåNG:
        - Tr·∫£ l·ªùi ph·∫£i ƒê·∫¶Y ƒê·ª¶ v√† TO√ÄN DI·ªÜN, bao g·ªìm m·ªçi kh√≠a c·∫°nh li√™n quan trong t√†i li·ªáu.
        - N·∫øu th√¥ng tin kh√¥ng ƒë·∫ßy ƒë·ªß, h√£y n√™u r√µ nh·ªØng kh√≠a c·∫°nh n√†o c·ªßa c√¢u h·ªèi ch∆∞a ƒë∆∞·ª£c tr·∫£ l·ªùi.
        - N·∫øu c·∫ßn c√¢u h·ªèi b·ªï sung ƒë·ªÉ l√†m r√µ, h√£y ƒë·ªÅ xu·∫•t.

        ### ƒê·ªäNH D·∫†NG C√ÇU TR·∫¢ L·ªúI:
        - Ti√™u ƒë·ªÅ: T√≥m t·∫Øt c√¢u tr·∫£ l·ªùi (1-2 d√≤ng)
        - C√¢u tr·∫£ l·ªùi chi ti·∫øt (chia th√†nh c√°c ph·∫ßn logic)
        - K·∫øt lu·∫≠n: T√≥m t·∫Øt c√°c ƒëi·ªÉm ch√≠nh
        `;
        
        // 5. G·ªçi LLM ƒë·ªÉ nh·∫≠n c√¢u tr·∫£ l·ªùi
        const answer = await generateAnswer(prompt);
        
        return answer;
    } catch (error) {
        console.error("‚ùå L·ªói trong h√†m searchPDF:", error);
        return "ƒê√£ x·∫£y ra l·ªói khi t√¨m ki·∫øm. Vui l√≤ng th·ª≠ l·∫°i sau.";
    }
}

// H√†m t·∫°o embedding
async function createEmbedding(text) {
    try {
        const openai = new OpenAI({
            apiKey: process.env.OPENAI_API_KEY
        });
        
        const response = await openai.embeddings.create({
            model: "text-embedding-ada-002",
            input: text
        });
        
        return response.data[0].embedding;
    } catch (error) {
        console.error("‚ùå L·ªói khi t·∫°o embedding:", error);
        return null;
    }
}

// H√†m sinh c√¢u tr·∫£ l·ªùi t·ª´ LLM b·∫±ng Gemini 2.0 Flash
async function generateAnswer(prompt) {
    try {
        const openai = new OpenAI({
            apiKey: process.env.OPENAI_API_KEY
        });
        
        const response = await openai.chat.completions.create({
            model: process.env.OPENAI_MODEL || "gpt-3.5-turbo-16k",
            messages: [
                { 
                    role: "system", 
                    content: "B·∫°n l√† tr·ª£ l√Ω AI chuy√™n nghi·ªáp v·ªõi kh·∫£ nƒÉng ph√¢n t√≠ch t√†i li·ªáu chuy√™n s√¢u. B·∫°n lu√¥n cung c·∫•p c√¢u tr·∫£ l·ªùi TO√ÄN DI·ªÜN, D√ÄI v√† ƒê·∫¶Y ƒê·ª¶ CHI TI·∫æT. H√£y s·ª≠ d·ª•ng t·∫•t c·∫£ th√¥ng tin li√™n quan t·ª´ t√†i li·ªáu ƒë·ªÉ tr·∫£ l·ªùi. ƒê·ª´ng b·ªè s√≥t b·∫•t k·ª≥ n·ªôi dung quan tr·ªçng n√†o. Khi tr√≠ch d·∫´n, ch·ªâ ƒë·ªÅ c·∫≠p ƒë·∫øn t√™n ƒë·∫ßy ƒë·ªß c·ªßa t√†i li·ªáu n·∫øu bi·∫øt. KH√îNG s·ª≠ d·ª•ng c√°ch g·ªçi 'T√†i li·ªáu 1', 'T√†i li·ªáu 2'. N·∫øu kh√¥ng bi·∫øt t√™n t√†i li·ªáu, h√£y b·ªè qua vi·ªác ƒë·ªÅ c·∫≠p t√™n t√†i li·ªáu. Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát."
                },
                { role: "user", content: prompt }
            ],
            temperature: 0.3,
            max_tokens: 8000,
            top_p: 0.95,
            frequency_penalty: 0.0,
            presence_penalty: 0.0
        });
        
        return response.choices[0].message.content;
    } catch (error) {
        console.error("‚ùå L·ªói khi t·∫°o c√¢u tr·∫£ l·ªùi:", error);
        return "ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω c√¢u tr·∫£ l·ªùi. Vui l√≤ng th·ª≠ l·∫°i sau.";
    }
}

module.exports = {
  registerResources,
  registerTools,
  registerPrompts,
  searchPDF,
  createEmbedding
}; 